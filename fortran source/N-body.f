  	program Nbody	integer part	PARAMETER (part=10)	integer time	doubleprecision pos(part,3),mass(part),vel(part,3)	character*25 str  	character*3 floobie	call initialize(mass,pos,vel)	do time=1,250		call Tstep(pos,vel,mass)		write(floobie,'(i3.3)') time	str='/u/osc216/dat/Body'//floobie//'.dat'		open(25,file=str, status='unknown')		do j=1,part			write(25,20) pos(j,1),pos(j,2),pos(j,3),mass(j)20	format (4f19.10)		end do		call header(time,part)	end do	end	Subroutine header(time,n)	  integer time,n	character*22 hstr	character*3 floobie	character*28 str	write(floobie,'(i3.3)') time	hstr='/u/osc216/fld/N'// floobie//'.fld'	    Open(26,file=hstr,status='unknown')	  str='/home/wrk005/dat/Body'//floobie//'.dat'	    Write(26,10) n,str,str,str,str10	Format('# AVS',/'ndim=1',/'dim1=',i2,/'nspace=3',/'veclen=1',     -		/'data=float',     -		/'field=irregular',/'variable 1 file=',A28,     -		' filetype=ascii offset=3 stride=4',     -		/'coord 1 file=',A28,     -		' filetype=ascii offset=0 stride=4',     -		/'coord 2 file=',A28,     -		' filetype=ascii offset=1 stride=4',     -		/'coord 3 file=',A28,     -		' filetype=ascii offset=2 stride=4')		return	end	Subroutine inttoStr(inte,str)		integer inte		character*3 str	str='000'		str(1:1)=char(ichar('0')+inte/100)	str(2:2)=char(ichar('0')+mod(inte,100)/10)	str(3:3)=char(ichar('0')+mod(inte,10))	return	end	Subroutine Initialize(mass,p0,v0)	integer part	PARAMETER (part=10)	doubleprecision mass(part)	doubleprecision p0(part,3)	doubleprecision v0(part,3)		doubleprecision avgmasspos(3)	doubleprecision c		doubleprecision KE,PE	n=part	iseed=134335243	call ranset(iseed)	do i=1,n	   mass(i)=int(ranf()*10)+1	end do			iseed=786547587	call ranset(iseed)	do i=1,n	  do j=1,3	    p0(i,j)=50-(100*ranf())	  end do	end do	do j=1,3		avgmasspos(j)=0	end do	do i=1,n		do j=1,3			avgmasspos(j)=avgmasspos(j)+mass(i)*p0(i,j)		end do	end do	do j=1,3		avgmasspos(j)=avgmasspos(j)/n	end do		do i=1,n			do j=1,3			p0(i,j)=p0(i,j)-avgmasspos(j)		end do	end doC   Velocity go here	call velocity(n,v0)	c=sqrt((-2*PE(p0,mass))/KE(v0,mass))	write (*,*) c	do i=1,n		do j=1,3			v0(i,j)=v0(i,j)*c		end do	end do	return	end		subroutine velocity(n,v)  		doubleprecision v1,v2, v(n,3)		iseed=8586443	call ranset(iseed)	v2=1.0d0-2.0d0*ranf()	iseed=231245	call ranset=iseed	do j=1,3	  do i=1,n	        r=2	     do while (r.gt.1.0d0)	        v1=v2	        v2=1.0d0-2.0d0*ranf()	        r=v1**2+v2**2	     end do	  r=sqrt(-2.0d0*log(r)/r)	  v(i,j)=v1*r	  end do	end do	return	end	Subroutine Tstep (q0,p0,m)	Parameter (Elimit=.001)	Parameter (Tlimit=.003)	integer part	PARAMETER (part=10)		doubleprecision q0(part,3)		doubleprecision p0(part,3)		doubleprecision q1(part,3)		doubleprecision p1(part,3)		doubleprecision f(part,3)		doubleprecision m(part)		 doubleprecision KE,PE		integer top,i,j		doubleprecision astack(8),step 	top=0	call push(astack,top,.025d0)	do while (top.GT.0)		call pop(astack,top,step)		call verlet (part, step, q0, q1, p0, p1, f,m)		if ((abs(PE(q0,m)+KE(p0,m)-     -		  PE(q1,m)+KE(p1,m)).GT.Elimit)     - 		   .AND. ((Step/2).GT.Tlimit)) then     			call push(astack,top,step/2)			call push(astack,top,step/2)		else			do i=1,part			   do j=1,3			      q0(i,j)=q1(i,j)			      p0(i,j)=p1(i,j)			   end do			end do		end if	end do	return	end	Subroutine pop (astack,top,popped)		doubleprecision astack(8),popped		integer top 	if (top.gt.0) then		popped=astack(top)		top=top-1	end if	return	end  	Subroutine push (astack,top,item)		doubleprecision astack(8),item		integer top 	top=top+1	astack(top)=item 	return	endc verlet.fcc This is the heart of the integration routine.	subroutine verlet (n, tau, p0, p1, v0, v1, f,mass)	implicit none	integer part	PARAMETER (part=10)	integer n, i, j	doubleprecision tau	doubleprecision p0 (part, 3)	doubleprecision p1 (part, 3)	doubleprecision v0 (part, 3)	doubleprecision v1 (part, 3)	doubleprecision f (part, 3)	doubleprecision mass (part)c	external forcesc use current momenta to integrate positions over half tau	Do j=1,3	  do i=1,n	    p1(i,j)=p0(i,j)+tau*v0(i,j)/2.0	  end do	end doc find the forces at this halfway point	call forces (n,p1,f,mass)c use the forces to integrate momenta over full tau	do j=1,3	  do i=1,n	    v1(i,j)=v0(i,j)+tau*f(i,j)	  end do	end doc use new momenta to integrate positions the rest of the way	do j=1,3	  do i=1,n	    p1(i,j)=p1(i,j)+tau*v1(i,j)/2.0	  end do	end do	return	end			subroutine forces (n,p1,f,m)	integer part	PARAMETER (part=10)	integer n,i,k	doubleprecision p1 (part,3)	doubleprecision f (part,3)	doubleprecision m (part)	doubleprecision vector1	doubleprecision vector2	doubleprecision vector3	doubleprecision a	doubleprecision j		doubleprecision distance	do i=1,10	  do k=1,3	   f(i,k)=0	  end do	end do	do i=1,9	 do k=i+1,10	   a=m(i)*m(k)	   	  j=a/(distance(p1,i,k))	    vector1=p1(k,1)-p1(i,1)	    vector2=p1(k,2)-p1(i,2)	    vector3=p1(k,3)-p1(i,3)	    	     f(k,1)=f(k,1)-j*vector1	     f(k,2)=f(k,2)-j*vector2	     f(k,3)=f(k,3)-j*vector3	     f(i,1)=f(i,1)+j*vector1	     f(i,2)=f(i,2)+j*vector2	     f(i,3)=f(i,3)+j*vector3	 end do	end do		return	end	doubleprecision Function Ke(Velvec,Mass)		integer part		PARAMETER (part=10)		doubleprecision Velvec(part,3)		doubleprecision Mass(part)		doubleprecision vel(part)		doubleprecision indKe(part),tempKE		integer i	TempKE=0.0d0	do i=1,part		vel(i)=Velvec(i,1)**2+Velvec(i,2)**2     -		+Velvec(i,3)**2		indKe(i)=0.5*mass(i)*vel(i)		TempKE=TempKE + indKE(i)	end do	KE=TempKE		Return	end	Doubleprecision Function Pe(Pos,Mass)		integer part		PARAMETER (part=10)		doubleprecision Pos(part,3)		doubleprecision Mass(part),tempPe		doubleprecision distance	TempPe=0	do i=1,part-1		do j=i+1,part		TempPe=TempPE+ (-1* ((Mass(i)* Mass(j))/     -			distance(pos,i,j)))		end do	end do	Pe=TempPe	return	end			doubleprecision  Function distance (pos,index1,index2)	integer part	PARAMETER (part=10)		doubleprecision pos(part,3)		integer index1,index2	distance=sqrt((pos(index2,1)-pos(index1,1))**2+     -               (pos(index2,2)-pos(index1,2))**2+     -               (pos(index2,3)-pos(index1,3))**2)	return	end	