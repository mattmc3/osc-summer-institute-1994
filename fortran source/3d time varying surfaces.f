      program surfacec***********************************************************************c*                                                                     *c*   Surface plotting program.                                         *c*                                                                     *c*   6/14/89 Dave Knight - initial version.                            *c*                                                                     *c***********************************************************************      parameter (NCOLS=640, NROWS=484)      character screen(0:NROWS*NCOLS-1,4)*1	! 2D image      real      zbuf(0:NROWS-1,0:NCOLS-1)	! buffer      common /image/ zbuf, screen      real      Ba		! distance of back clipping plane to proj. plane      real      COP(4)		! center of projections (eye pt. rel. to VRP      real      eye(4)		! eye point      real      eye2pp		! distance of eye to projection plane      real      F		! distance of front clipping plane to proj. pl.      integer   frame		! current frame      integer   frameinc	! increment between successive frames      integer   frames		! upper limit of frame      integer   framestart	! lower limit of frame      real	light(4)	! light source of specular highlights      real      MinDist		! distance of front clip. plane after trans.      real      P(4)		! a 3D point      real      subj(4)		! point of focus      real      uvmin(2)	! corner of projection plane      real      uvmax(2)	! corner of projection plane      real      Viewmat(4,4)	! viewing transformation matrix      real      VPN(4)		! View Plane Normal      real      VRP(4)		! View Reference Point      real      VUP(4)		! View UP      real    	wrldmin(4)	! corner of bounding box      real    	wrldmax(4)	! corner of bounding box      real    	xc		! x coordinate      real	xint		! delta x for surface      real    	yc		! y coordinate      real	yint		! delta y for surfacecc * initializec      call init(wrldmin, wrldmax, uvmin, uvmax, frames, frameinc,      .          framestart, yint, xint, Ba)      do frame = framestart, frames, frameinc         write (*,*) 'main 1:frames=',frames, ', frame #',frame          call view (frame, eye2pp, eye, subj, VUP, light)         write (*,*) 'main 2:eye=',eye(1),',',eye(2),',',eye(3)         write (*,*) '      :subj=',subj(1),',',subj(2),',',subj(3)         write (*,*) '      :VUP=',VUP(1),',',VUP(2),',',VUP(3)         write (*,*) '      :light=',light(1),',',light(2),',',light(3)         write (*,*) '      :eye2pp=',eye2ppcc * process framec         call viewcnvrt(eye, subj, eye2pp, VUP, VRP, VPN, COP, F)         call xform(VRP, VPN, VUP, COP, uvmin, uvmax, F, Ba,      .                 Viewmat, MinDist)cc * generate each rowc         xc = wrldmin(1)         do while (xc .le. wrldmax(1)+xint/100.0)cc * generate each columnc            yc = wrldmin(2)            do while (yc .le. wrldmax(2)+yint/100.0)               call func(frame, xc, yc, wrldmin, wrldmax, P)               if (((P(1).ne.eye(1)) .or. (P(2).ne.eye(2)) .or.     .              (P(3).ne.eye(3))) .and.      .             ((P(1).ne.light(1)) .or. (P(2).ne.light(2)) .or.     .              (P(3).ne.light(3)))) then                  call proj(frame, P, Viewmat, MinDist, eye, light,     .                      wrldmin, wrldmax)               end if               yc = yc + yint            end do            xc = xc + xint         end do         call out (frame)      end do      stop      end      function dot(v1, v2)c***********************************************************************c*                                                                     *c*   return the dot product of v1 & v2                                 *c*                                                                     *c***********************************************************************      real	v1(4)		! vector      real	v2(4)		! vector      dot = v1(1) * v2(1) + v1(2) * v2(2) + v1(3) * v2(3)      return      end      subroutine cross(v1, v2, v3)c***********************************************************************c*                                                                     *c*   v3 is the cross product of v1 & v2                                *c*                                                                     *c***********************************************************************      real	v1(4)		! vector      real	v2(4)		! vector      real	v3(4)		! vector      v3(1) = v1(2) * v2(3) - v1(3) * v2(2)      v3(2) = v1(3) * v2(1) - v1(1) * v2(3)      v3(3) = v1(1) * v2(2) - v1(2) * v2(1)      v3(4) = 1.0      return      end       subroutine norm(v1)c***********************************************************************c*                                                                     *c*   normalize vector v1's length to 1.0                               *c*                                                                     *c***********************************************************************      real	v1(4)		! vector      real	length      integer	i		! index      length = SQRT(dot(v1,v1))      do i = 1, 4         v1(i) = v1(i) / length      end do      return      end       subroutine ident(m1)c***********************************************************************c*                                                                     *c*   initialize matrix m1 to the identity matrix                       *c*                                                                     *c***********************************************************************      real	m1(4,4)		! matrix      integer   irow		! row index      integer   icol		! column index      do irow = 1, 4         do icol = 1, 4            if (irow .eq. icol) then               m1(irow,icol) = 1.0            else               m1(irow,icol) = 0.0            end if         end do      end do      return      end       subroutine matmult(m1, m2, m3)c***********************************************************************c*                                                                     *c*   m3 is the product of matrices m1 & m2                             *c*                                                                     *c***********************************************************************      real	m1(4,4)		! matrix      real	m2(4,4)		! matrix      real	m3(4,4)		! matrix      integer   irow		! row index      integer   icol		! column index      integer   i		! index      do irow = 1, 4         do icol = 1, 4            m3(irow,icol) = 0.0            do i = 1, 4               m3(irow,icol) = m3(irow,icol) + m1(irow,i) * m2(i,icol)            end do         end do      end do      return      end       subroutine vecmult(m1, v1, v2)c***********************************************************************c*                                                                     *c*   v2 is the product of vector v1 & matrix m1                        *c*                                                                     *c***********************************************************************      real	m1(4,4)		! matrix      real	v1(4)		! vector      real	v2(4)		! vector      integer   icol		! column index      do icol = 1, 4         v2(icol) = v1(1) * m1(1,icol) + v1(2) * m1(2,icol) +     .              v1(3) * m1(3,icol) + v1(4) * m1(4,icol)      end do      return      end       subroutine sclrmult(s1, v1, v2)c***********************************************************************c*                                                                     *c*   v2 is the product of vector v1 & matrix m1                        *c*                                                                     *c***********************************************************************      real	s1		! scalar      real	v1(4)		! vector      real	v2(4)		! vector      v2(1) = s1 * v1(1)      v2(2) = s1 * v1(2)      v2(3) = s1 * v1(3)      v2(4) = 1.0      return      end       subroutine vecsub(v1, v2, v3)c***********************************************************************c*                                                                     *c*   v3 is the vector resulting from v1 - v2                           *c*                                                                     *c***********************************************************************      real	v1(4)		! vector      real	v2(4)		! vector      real	v3(4)		! vector      v3(1) = v1(1) - v2(1)      v3(2) = v1(2) - v2(2)      v3(3) = v1(3) - v2(3)      v3(4) = 1.0      return      end       subroutine vecadd(v1, v2, v3)c***********************************************************************c*                                                                     *c*   v3 is the vector resulting from v1 + v2                           *c*                                                                     *c***********************************************************************      real	v1(4)		! vector      real	v2(4)		! vector      real	v3(4)		! vector      v3(1) = v1(1) + v2(1)      v3(2) = v1(2) + v2(2)      v3(3) = v1(3) + v2(3)      v3(4) = 1.0      return      end       subroutine proj(frame, P, Viewmat, MinDist, eye, light, wrldmin,     .                wrldmax)c***********************************************************************c*                                                                     *c*   proj applies the viewing transformation to a 3D point and clips   *c*   it to get the 2D projection that's stored into screen             *c*   using the colors determined by colour(r, g, b).                   *c*                                                                     *c***********************************************************************      parameter (NCOLS=640, NROWS=484)      character screen(0:NROWS*NCOLS-1,4)*1	! 2D image      real      zbuf(0:NROWS-1,0:NCOLS-1)	! buffer      common /image/ zbuf, screen      integer   BOXm1      integer   frame		! current frame      real      P(4)		! a 3D point      real      Viewmat(4,4)	! viewing transformation matrix      real      MinDist		! distance of front clip. plane after trans.      real      eye(4)		! eye point      real	light(4)	! light source of specular highlights      real    	wrldmin(4)	! corner of bounding box      real    	wrldmax(4)	! corner of bounding box      real      ambient         ! see diffuse (0=none, 1=fully lit)      real      diffuse         ! 0 <= ambient+diffuse <= 1      integer   col		! point x (screen system)      integer   colwork		! pixel loop index      real	delta(4)	! vector of P to eye      real	distance	! suare of distance of P to eye      logical	first		! indicates whether color has been assigned      integer	index		! index for 2D -> 1D array      real	Pprime(4)	! transformed point      character rgb(4)*1	! red, green and blue values      integer	rindex		! row index for 2D -> 1D array      integer	row		! point y (screen system)      integer	rowwork		! pixel loop index      real	saturation	! color saturation (0=none, 1=saturated)      BOXm1 = 2      call vecmult(Viewmat, P, Pprime)      if (Pprime(3) .ge. MinDist) thencc * point on visible side of the front clip planec         if ((Pprime(1) .ge. -Pprime(3)) .and.      .       (Pprime(1) .le.  Pprime(3))) thencc * horizonal component of point is within clip boundsc            if ((Pprime(2) .ge. -Pprime(3)) .and.     .          (Pprime(2) .le.  Pprime(3))) thencc * point is within clipping boundsc               call vecsub(eye, P, delta)               distance = dot(delta, delta)cc * flip point because (0,0) is upper left of screenc               col = INT((Pprime(1)/Pprime(3)+1.0) / 2.0*(NCOLS-1)-1)               col = NCOLS - col               row = INT((Pprime(2)/Pprime(3)+1.0) / 2.0*(NROWS-1)-1)c              row = NROWS - row               first = .TRUE.cc * store a row of pixels on current columnc               do rowwork = row, row+BOXm1                  if (rowwork.ge.0 .and. rowwork.lt.NROWS) then                     do colwork = col, col+BOXm1cc * store a column of pixels near a pointc                        if (colwork.ge.0 .and. colwork.lt.NCOLS) then                           rindex = rowwork * NCOLS                           if (distance .lt. zbuf(rowwork,colwork)) then                              if (first) then                                 first = .FALSE.                                 call lighting(frame, P, eye, light,     .                                         wrldmin, wrldmax,      .                                         saturation, ambient,      .                                         diffuse)                                 call colour(P, saturation, ambient,     .                                       diffuse, wrldmin, wrldmax,     .                                       rgb)                              end if                              index = rindex + colwork                              zbuf(rowwork,colwork) = distance                              screen(index,2) = rgb(1)                              screen(index,3) = rgb(2)                              screen(index,4) = rgb(3)                           end if                        end if                     end do                  end if               end do            end if         end if      end if      return      end      subroutine lighting(frame, P, eye, light, wrldmin, wrldmax,     .                    saturation, ambient, diffuse)c***********************************************************************c*                                                                     *c*   lighting calculates the specular highlight, and ambient and       *c*   diffuse light components at a point.  For the specular highlight  *c*   it does this by taking the differene in the angle between the     *c*   normal to the surface at the point and the midpoint of the        *c*   eye-to-point-to-light angle.  The closer these two vectors, the   *c*   greater the specular highlight (i.e., glare).  The value returned *c*   for the specular highlight ranges between 0. and 1.  Zero         *c*   represents the maximum glare, and 1. represents the minimum       *c*   glare.                                                            *c*                                                                     *c*   The ambient light is constant.  The diffuse light is a function   *c*   of the cosine of the angle between the light and the surface      *c*   normal at a point on the surface.  The values returned for        *c*   ambient light and diffuse light must, as a sum, range between 0.  *c*   and 1.  Zero represents no light on the point, and 1.  represents *c*   the maximum light on the point.                                   *c*                                                                     *c*   6/22/89 Dave Knight - initial version.                            *c*                                                                     *c***********************************************************************      integer   frame		! current frame      real      P(4)		! a 3D point      real      eye(4)		! eye point      real	light(4)	! light source of specular highlights      real    	wrldmin(4)	! corner of bounding box      real    	wrldmax(4)	! corner of bounding box      real	saturation	! color saturation (0=none, 1=saturated)      real      ambient         ! see diffuse (0=none, 1=fully lit)      real      diffuse         ! 0 <= ambient+diffuse <= 1      real	diffangle	! cosine of angle between P2light and surfnorm      real	highlight	! cosine of angle between Pmax and surfnorm      real	P2eye(4)	! unit length vector from P towards eye      real      P2light(4)	! unit length vector from P towards light      real      Pmax(4)		! unit length vector from P -> max spec. high.      real      Px(4)		! point on surface with small displacement      real      Py(4)		! point on surface with small displacement      real      surfx(4)	! vector tangent to surface at P in plane y=P[Y]      real      surfy(4)	! vector tangent to surface at P in plane x=P[X]      real      surfnorm(4)	! unit length vector normal to surface at Pcc * calculate the direction at P where the specular highlight is maxc      call vecsub(eye, P, P2eye)      call norm(P2eye)      call vecsub(light, P, P2light)      call norm(P2light)      call vecadd(P2eye, P2light, Pmax)      call norm(Pmax)cc * calculate the direction at P of the surface normalc      call func(frame, P(1)+0.01, P(2), wrldmin, wrldmax, Px)      call func(frame, P(1), P(2)+0.01, wrldmin, wrldmax, Py)      call vecsub(Px, P, surfx)      call vecsub(Py, P, surfy)      call cross(surfx, surfy, surfnorm)      call norm(surfnorm)cc * calculte cosine of angle between max spec highlight & surface norm at Pc      highlight = dot(Pmax, surfnorm)cc * calculate the saturation attribute at Pc      highlight = highlight * highlight      highlight = highlight * highlight * highlight      saturation = 1.0 - highlight * 0.5cc * calculate ambient and diffuse light components at Pc      ambient = 0.3      diffangle = dot(P2light, surfnorm)      if (diffangle .lt. 0.0) diffangle = 0.0	! points back to surface      diffuse = (1.0 - ambient) * diffangle       return      end      subroutine viewcnvrt(eye, subj, eye2pp, VUP, VRP, VPN, COP, F) c***********************************************************************c*                                                                     *c*   viewcnvrt converts the easy viewing parameters define in view     *c*   to hard parameters required by xform.                             *c*                                                                     *c***********************************************************************      parameter (NCOLS=640, NROWS=484, HUGE=3.3E38)      character screen(0:NROWS*NCOLS-1,4)*1	! 2D image      real      zbuf(0:NROWS-1,0:NCOLS-1)	! buffer      common /image/ zbuf, screen      real      eye(4)		! eye point      real      subj(4)		! point of focus      real      eye2pp		! distance of eye to projection plane      real      VPN(4)		! View Plane Normal      real      VRP(4)		! View Reference Point      real      VUP(4)		! View UP      real      COP(4)		! center of projections (eye pt. rel. to VRP      real      F		! distance of front clipping plane to proj. pl.      integer	col		! loop index      integer 	index		! index for 2D -> 1D array      real	eye2subj	! distance from eye to the subject focii      real	prop		! ratio of eye2pp to eye2subj      integer	row		! loop indexcc * initializec      VUP(4) = 1.0      call vecsub(subj, eye, VPN)      eye2subj = SQRT(VPN(1)*VPN(1) + VPN(2)*VPN(2) + VPN(3)*VPN(3))      prop = -eye2pp / eye2subj      call sclrmult(prop, VPN, COP)      call vecsub(eye, COP, VRP)      F = -eye2pp      index = 0      do row = 0, NROWS-1         do col = 0, NCOLS-1            screen(index,1) = CHAR(0)            screen(index,2) = CHAR(0)            screen(index,3) = CHAR(0)            screen(index,4) = CHAR(0)            zbuf(row,col) = HUGE            index = index + 1         end do      end do      return      end      subroutine xform(VRP, VPN, VUP, COP, uvmin, uvmax, F, Ba,     .                 Viewmat, MinDist)c***********************************************************************c*                                                                     *c*   xform implements the process described in section 11-7 of         *c*   'Computer Graphics with PASCAL,' by Marc Berger, pub. by the      *c*   Benjamin/Cummings Publishing Co., Inc., (c) 1986.  xform sets up  *c*   the transformation matrix used to convert the 3-dimensional       *c*   surface coordinates to 2-dimensional viewing coordinates.         *c*                                                                     *c*   6/2/89 Dave Knight - initial version.                             *c*                                                                     *c***********************************************************************      real      VPN(4)		! View Plane Normal      real      VRP(4)		! View Reference Point      real      VUP(4)		! View UP      real      COP(4)		! center of projections (eye pt. rel. to VRP      real      uvmin(2)	! corner of projection plane      real      uvmax(2)	! corner of projection plane      real      F		! distance of front clipping plane to proj. pl.      real      Ba		! distance of back clipping plane to proj. plane      real      Viewmat(4,4)	! viewing transformation matrix      real      MinDist		! distance of front clip. plane after trans.      real	tempvect(4)	! temporary vector      real	vv(4)		! vertical direction on projection plane      real	uu(4)		! horizontal direction on projection plane      real      scalar		      real	T(4,4)		! translation matrix (moves the surface)      real      Rot(4,4)	! rotation matrix (rotates the surface)      real      VRPprime(4)	! VRP relative to the surface      real	Sh(4,4)		! z-shear matrix      real	Sc(4,4)		! scale matrix      real	tempmat(4,4)	! temporary matrixcc * determine the u,v coordinate systemc      call norm(VPN)      scalar = dot(VPN, VUP)      call sclrmult(scalar, VPN, tempvect)      call vecsub(VUP, tempvect, vv)      call cross(VPN, vv, uu)cc * transform VRP to VRPprime (i.e., VRP relative to the surface)c      call ident(T)      T(4,1) = -VRP(1) - COP(1)      T(4,2) = -VRP(2) - COP(2)      T(4,3) = -VRP(3) - COP(3)      call ident(Rot)      Rot(1,1) = uu(1)      Rot(2,1) = uu(2)      Rot(3,1) = uu(3)      Rot(1,2) = vv(1)      Rot(2,2) = vv(2)      Rot(3,2) = vv(3)      Rot(1,3) = VPN(1)      Rot(2,3) = VPN(2)      Rot(3,3) = VPN(3)      call matmult(T, Rot, Viewmat)      call vecmult(Viewmat, VRP, VRPprime)cc * create the surface viewing matrixc      call ident(Sh)      Sh(3,1) = -(VRPprime(1) + (uvmin(1) + uvmax(1)) / 2.0 ) /     .            VRPprime(3)      Sh(3,2) = -(VRPprime(2) + (uvmin(2) + uvmax(2)) / 2.0 ) /     .            VRPprime(3)      call matmult(Viewmat, Sh, tempmat)      call ident(Sc)      Sc(1,1) = 2.0 * VRPprime(3) / ((uvmax(1) - uvmin(1)) *      .                           (VRPprime(3) + Ba))      Sc(2,2) = 2.0 * VRPprime(3) / ((uvmax(2) - uvmin(2)) *      .                           (VRPprime(3) + Ba))      Sc(3,3) = 1.0 / (VRPprime(3) + Ba)      call matmult(tempmat, Sc, Viewmat)cc * determine MinDist, for clipping later onc      MinDist = (VRPprime(3) + F) / (VRPprime(3) + Ba)      return      end      subroutine out(frame)c***********************************************************************c*                                                                     *c*   out writes the raster picture for the current frame.              *c*                                                                     *c***********************************************************************      parameter (NCOLS=640, NROWS=484, lun=11)      character screen(0:NROWS*NCOLS-1,4)*1	! 2D image      real      zbuf(0:NROWS-1,0:NCOLS-1)	! buffer      common /image/ zbuf, screen      integer	frame		! current frame       character filename*8	! name of filecc * output field filec      filename = 'i000.fld'      write (filename(2:4),'(i3.3)') frame      open (unit=lun, file=filename, status='UNKNOWN')      filename = 'i000.raw'      write (filename(2:4),'(i3.3)') frame      write (lun, 11) NCOLS, NROWS,      .                filename, filename, filename, filename      close (lun)cc * output datac      open (lun, file=filename, form='UNFORMATTED', access='DIRECT',      .      RECL=NROWS*NCOLS*4, status='UNKNOWN')      write (lun, REC=1) ((screen(i,j),j=1,4),i=0,NROWS*NCOLS-1)      close (lun)    11 format('# AVS field file',/,     .       '# ',/,     .       'ndim=2',/,     .       'dim1=',i3,/,     .       'dim2=',i3,/,     .       'nspace=2',/,     .       'veclen=4',/,     .       'data=byte',/,     .       'field=uniform',/,     .       'variable 1 file=',a8,' filetype=binary stride=4',/,     .       'variable 2 file=',a8,' filetype=binary skip=1 stride=4',/,     .       'variable 3 file=',a8,' filetype=binary skip=2 stride=4',/,     .       'variable 4 file=',a8,' filetype=binary skip=3 stride=4')       return      end